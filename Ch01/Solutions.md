
# Self-Review Exercises Solutions

## 1.1

a. Programs.
b. Input units, output units, ALU (arithmetic and logic unit), CPU (central processing unit), secondary storage unit, memory unit.
c. Machine Language, Assembly Language, High-Level Language.
d. Compilers.
e. Android.
f. Release Candidate.
g. accelerometer.

## 1.2

a. java "name of the file with .class extension".
b. javac "name of the file with .java extension".
c. .java.
d. .class.
e. Bytecode.

## 1.3

a. Information hiding.
b. Classes.
c. OOAD (object oriented analysis and design).
d. Inheritance.
e. UML (unified modeling language).
f. Attributes.

---

# Exercises Solutions

## 1.4

a. Input unit.
b. Programming.
c. Assembly.
d. Output devices.
e. Memory unit, secondary storage unit.
f. ALU (arithmetic and logical unit).
g. CPU (central processing unit).
h. High level languages.
i. Machine language.
j. CPU (central processing unit).

## 1.5

a. Java.
b. Java SE (standard edition), Java EE (enterprise edition), Java ME (micro edition).
c. Bandwidth.
d. Assembler.

## 1.6

a. Editing, compiling, loading, bytecode verification, and execution.
b. IDE (integrated development environment).
c. JVM (java virtual machine).
d. VM (virtual machine).
e Class Loader.
f. Bytecode Validator.

## 1.7

JVM analyzes the bytecodes as they’re interpreted, searching for hot spots—bytecodes that execute frequently. For these parts, a just-in-time
(JIT) compiler, translates the bytecodes into the
computer’s machine language. When the JVM encounters these compiled parts again, the
faster machine-language code executes.

